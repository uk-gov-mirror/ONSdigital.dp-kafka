// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/ONSdigital/dp-kafka"
	"github.com/Shopify/sarama"
	"sync"
)

var (
	lockSaramaClientMockBrokers            sync.RWMutex
	lockSaramaClientMockClose              sync.RWMutex
	lockSaramaClientMockClosed             sync.RWMutex
	lockSaramaClientMockConfig             sync.RWMutex
	lockSaramaClientMockController         sync.RWMutex
	lockSaramaClientMockCoordinator        sync.RWMutex
	lockSaramaClientMockGetOffset          sync.RWMutex
	lockSaramaClientMockInSyncReplicas     sync.RWMutex
	lockSaramaClientMockInitProducerID     sync.RWMutex
	lockSaramaClientMockLeader             sync.RWMutex
	lockSaramaClientMockOfflineReplicas    sync.RWMutex
	lockSaramaClientMockPartitions         sync.RWMutex
	lockSaramaClientMockRefreshCoordinator sync.RWMutex
	lockSaramaClientMockRefreshMetadata    sync.RWMutex
	lockSaramaClientMockReplicas           sync.RWMutex
	lockSaramaClientMockTopics             sync.RWMutex
	lockSaramaClientMockWritablePartitions sync.RWMutex
)

// Ensure, that SaramaClientMock does implement kafka.SaramaClient.
// If this is not the case, regenerate this file with moq.
var _ kafka.SaramaClient = &SaramaClientMock{}

// SaramaClientMock is a mock implementation of kafka.SaramaClient.
//
//     func TestSomethingThatUsesSaramaClient(t *testing.T) {
//
//         // make and configure a mocked kafka.SaramaClient
//         mockedSaramaClient := &SaramaClientMock{
//             BrokersFunc: func() []*sarama.Broker {
// 	               panic("mock out the Brokers method")
//             },
//             CloseFunc: func() error {
// 	               panic("mock out the Close method")
//             },
//             ClosedFunc: func() bool {
// 	               panic("mock out the Closed method")
//             },
//             ConfigFunc: func() *sarama.Config {
// 	               panic("mock out the Config method")
//             },
//             ControllerFunc: func() (*sarama.Broker, error) {
// 	               panic("mock out the Controller method")
//             },
//             CoordinatorFunc: func(consumerGroup string) (*sarama.Broker, error) {
// 	               panic("mock out the Coordinator method")
//             },
//             GetOffsetFunc: func(topic string, partitionID int32, time int64) (int64, error) {
// 	               panic("mock out the GetOffset method")
//             },
//             InSyncReplicasFunc: func(topic string, partitionID int32) ([]int32, error) {
// 	               panic("mock out the InSyncReplicas method")
//             },
//             InitProducerIDFunc: func() (*sarama.InitProducerIDResponse, error) {
// 	               panic("mock out the InitProducerID method")
//             },
//             LeaderFunc: func(topic string, partitionID int32) (*sarama.Broker, error) {
// 	               panic("mock out the Leader method")
//             },
//             OfflineReplicasFunc: func(topic string, partitionID int32) ([]int32, error) {
// 	               panic("mock out the OfflineReplicas method")
//             },
//             PartitionsFunc: func(topic string) ([]int32, error) {
// 	               panic("mock out the Partitions method")
//             },
//             RefreshCoordinatorFunc: func(consumerGroup string) error {
// 	               panic("mock out the RefreshCoordinator method")
//             },
//             RefreshMetadataFunc: func(topics ...string) error {
// 	               panic("mock out the RefreshMetadata method")
//             },
//             ReplicasFunc: func(topic string, partitionID int32) ([]int32, error) {
// 	               panic("mock out the Replicas method")
//             },
//             TopicsFunc: func() ([]string, error) {
// 	               panic("mock out the Topics method")
//             },
//             WritablePartitionsFunc: func(topic string) ([]int32, error) {
// 	               panic("mock out the WritablePartitions method")
//             },
//         }
//
//         // use mockedSaramaClient in code that requires kafka.SaramaClient
//         // and then make assertions.
//
//     }
type SaramaClientMock struct {
	// BrokersFunc mocks the Brokers method.
	BrokersFunc func() []*sarama.Broker

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ClosedFunc mocks the Closed method.
	ClosedFunc func() bool

	// ConfigFunc mocks the Config method.
	ConfigFunc func() *sarama.Config

	// ControllerFunc mocks the Controller method.
	ControllerFunc func() (*sarama.Broker, error)

	// CoordinatorFunc mocks the Coordinator method.
	CoordinatorFunc func(consumerGroup string) (*sarama.Broker, error)

	// GetOffsetFunc mocks the GetOffset method.
	GetOffsetFunc func(topic string, partitionID int32, time int64) (int64, error)

	// InSyncReplicasFunc mocks the InSyncReplicas method.
	InSyncReplicasFunc func(topic string, partitionID int32) ([]int32, error)

	// InitProducerIDFunc mocks the InitProducerID method.
	InitProducerIDFunc func() (*sarama.InitProducerIDResponse, error)

	// LeaderFunc mocks the Leader method.
	LeaderFunc func(topic string, partitionID int32) (*sarama.Broker, error)

	// OfflineReplicasFunc mocks the OfflineReplicas method.
	OfflineReplicasFunc func(topic string, partitionID int32) ([]int32, error)

	// PartitionsFunc mocks the Partitions method.
	PartitionsFunc func(topic string) ([]int32, error)

	// RefreshCoordinatorFunc mocks the RefreshCoordinator method.
	RefreshCoordinatorFunc func(consumerGroup string) error

	// RefreshMetadataFunc mocks the RefreshMetadata method.
	RefreshMetadataFunc func(topics ...string) error

	// ReplicasFunc mocks the Replicas method.
	ReplicasFunc func(topic string, partitionID int32) ([]int32, error)

	// TopicsFunc mocks the Topics method.
	TopicsFunc func() ([]string, error)

	// WritablePartitionsFunc mocks the WritablePartitions method.
	WritablePartitionsFunc func(topic string) ([]int32, error)

	// calls tracks calls to the methods.
	calls struct {
		// Brokers holds details about calls to the Brokers method.
		Brokers []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Closed holds details about calls to the Closed method.
		Closed []struct {
		}
		// Config holds details about calls to the Config method.
		Config []struct {
		}
		// Controller holds details about calls to the Controller method.
		Controller []struct {
		}
		// Coordinator holds details about calls to the Coordinator method.
		Coordinator []struct {
			// ConsumerGroup is the consumerGroup argument value.
			ConsumerGroup string
		}
		// GetOffset holds details about calls to the GetOffset method.
		GetOffset []struct {
			// Topic is the topic argument value.
			Topic string
			// PartitionID is the partitionID argument value.
			PartitionID int32
			// Time is the time argument value.
			Time int64
		}
		// InSyncReplicas holds details about calls to the InSyncReplicas method.
		InSyncReplicas []struct {
			// Topic is the topic argument value.
			Topic string
			// PartitionID is the partitionID argument value.
			PartitionID int32
		}
		// InitProducerID holds details about calls to the InitProducerID method.
		InitProducerID []struct {
		}
		// Leader holds details about calls to the Leader method.
		Leader []struct {
			// Topic is the topic argument value.
			Topic string
			// PartitionID is the partitionID argument value.
			PartitionID int32
		}
		// OfflineReplicas holds details about calls to the OfflineReplicas method.
		OfflineReplicas []struct {
			// Topic is the topic argument value.
			Topic string
			// PartitionID is the partitionID argument value.
			PartitionID int32
		}
		// Partitions holds details about calls to the Partitions method.
		Partitions []struct {
			// Topic is the topic argument value.
			Topic string
		}
		// RefreshCoordinator holds details about calls to the RefreshCoordinator method.
		RefreshCoordinator []struct {
			// ConsumerGroup is the consumerGroup argument value.
			ConsumerGroup string
		}
		// RefreshMetadata holds details about calls to the RefreshMetadata method.
		RefreshMetadata []struct {
			// Topics is the topics argument value.
			Topics []string
		}
		// Replicas holds details about calls to the Replicas method.
		Replicas []struct {
			// Topic is the topic argument value.
			Topic string
			// PartitionID is the partitionID argument value.
			PartitionID int32
		}
		// Topics holds details about calls to the Topics method.
		Topics []struct {
		}
		// WritablePartitions holds details about calls to the WritablePartitions method.
		WritablePartitions []struct {
			// Topic is the topic argument value.
			Topic string
		}
	}
}

// Brokers calls BrokersFunc.
func (mock *SaramaClientMock) Brokers() []*sarama.Broker {
	if mock.BrokersFunc == nil {
		panic("SaramaClientMock.BrokersFunc: method is nil but SaramaClient.Brokers was just called")
	}
	callInfo := struct {
	}{}
	lockSaramaClientMockBrokers.Lock()
	mock.calls.Brokers = append(mock.calls.Brokers, callInfo)
	lockSaramaClientMockBrokers.Unlock()
	return mock.BrokersFunc()
}

// BrokersCalls gets all the calls that were made to Brokers.
// Check the length with:
//     len(mockedSaramaClient.BrokersCalls())
func (mock *SaramaClientMock) BrokersCalls() []struct {
} {
	var calls []struct {
	}
	lockSaramaClientMockBrokers.RLock()
	calls = mock.calls.Brokers
	lockSaramaClientMockBrokers.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *SaramaClientMock) Close() error {
	if mock.CloseFunc == nil {
		panic("SaramaClientMock.CloseFunc: method is nil but SaramaClient.Close was just called")
	}
	callInfo := struct {
	}{}
	lockSaramaClientMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockSaramaClientMockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedSaramaClient.CloseCalls())
func (mock *SaramaClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockSaramaClientMockClose.RLock()
	calls = mock.calls.Close
	lockSaramaClientMockClose.RUnlock()
	return calls
}

// Closed calls ClosedFunc.
func (mock *SaramaClientMock) Closed() bool {
	if mock.ClosedFunc == nil {
		panic("SaramaClientMock.ClosedFunc: method is nil but SaramaClient.Closed was just called")
	}
	callInfo := struct {
	}{}
	lockSaramaClientMockClosed.Lock()
	mock.calls.Closed = append(mock.calls.Closed, callInfo)
	lockSaramaClientMockClosed.Unlock()
	return mock.ClosedFunc()
}

// ClosedCalls gets all the calls that were made to Closed.
// Check the length with:
//     len(mockedSaramaClient.ClosedCalls())
func (mock *SaramaClientMock) ClosedCalls() []struct {
} {
	var calls []struct {
	}
	lockSaramaClientMockClosed.RLock()
	calls = mock.calls.Closed
	lockSaramaClientMockClosed.RUnlock()
	return calls
}

// Config calls ConfigFunc.
func (mock *SaramaClientMock) Config() *sarama.Config {
	if mock.ConfigFunc == nil {
		panic("SaramaClientMock.ConfigFunc: method is nil but SaramaClient.Config was just called")
	}
	callInfo := struct {
	}{}
	lockSaramaClientMockConfig.Lock()
	mock.calls.Config = append(mock.calls.Config, callInfo)
	lockSaramaClientMockConfig.Unlock()
	return mock.ConfigFunc()
}

// ConfigCalls gets all the calls that were made to Config.
// Check the length with:
//     len(mockedSaramaClient.ConfigCalls())
func (mock *SaramaClientMock) ConfigCalls() []struct {
} {
	var calls []struct {
	}
	lockSaramaClientMockConfig.RLock()
	calls = mock.calls.Config
	lockSaramaClientMockConfig.RUnlock()
	return calls
}

// Controller calls ControllerFunc.
func (mock *SaramaClientMock) Controller() (*sarama.Broker, error) {
	if mock.ControllerFunc == nil {
		panic("SaramaClientMock.ControllerFunc: method is nil but SaramaClient.Controller was just called")
	}
	callInfo := struct {
	}{}
	lockSaramaClientMockController.Lock()
	mock.calls.Controller = append(mock.calls.Controller, callInfo)
	lockSaramaClientMockController.Unlock()
	return mock.ControllerFunc()
}

// ControllerCalls gets all the calls that were made to Controller.
// Check the length with:
//     len(mockedSaramaClient.ControllerCalls())
func (mock *SaramaClientMock) ControllerCalls() []struct {
} {
	var calls []struct {
	}
	lockSaramaClientMockController.RLock()
	calls = mock.calls.Controller
	lockSaramaClientMockController.RUnlock()
	return calls
}

// Coordinator calls CoordinatorFunc.
func (mock *SaramaClientMock) Coordinator(consumerGroup string) (*sarama.Broker, error) {
	if mock.CoordinatorFunc == nil {
		panic("SaramaClientMock.CoordinatorFunc: method is nil but SaramaClient.Coordinator was just called")
	}
	callInfo := struct {
		ConsumerGroup string
	}{
		ConsumerGroup: consumerGroup,
	}
	lockSaramaClientMockCoordinator.Lock()
	mock.calls.Coordinator = append(mock.calls.Coordinator, callInfo)
	lockSaramaClientMockCoordinator.Unlock()
	return mock.CoordinatorFunc(consumerGroup)
}

// CoordinatorCalls gets all the calls that were made to Coordinator.
// Check the length with:
//     len(mockedSaramaClient.CoordinatorCalls())
func (mock *SaramaClientMock) CoordinatorCalls() []struct {
	ConsumerGroup string
} {
	var calls []struct {
		ConsumerGroup string
	}
	lockSaramaClientMockCoordinator.RLock()
	calls = mock.calls.Coordinator
	lockSaramaClientMockCoordinator.RUnlock()
	return calls
}

// GetOffset calls GetOffsetFunc.
func (mock *SaramaClientMock) GetOffset(topic string, partitionID int32, time int64) (int64, error) {
	if mock.GetOffsetFunc == nil {
		panic("SaramaClientMock.GetOffsetFunc: method is nil but SaramaClient.GetOffset was just called")
	}
	callInfo := struct {
		Topic       string
		PartitionID int32
		Time        int64
	}{
		Topic:       topic,
		PartitionID: partitionID,
		Time:        time,
	}
	lockSaramaClientMockGetOffset.Lock()
	mock.calls.GetOffset = append(mock.calls.GetOffset, callInfo)
	lockSaramaClientMockGetOffset.Unlock()
	return mock.GetOffsetFunc(topic, partitionID, time)
}

// GetOffsetCalls gets all the calls that were made to GetOffset.
// Check the length with:
//     len(mockedSaramaClient.GetOffsetCalls())
func (mock *SaramaClientMock) GetOffsetCalls() []struct {
	Topic       string
	PartitionID int32
	Time        int64
} {
	var calls []struct {
		Topic       string
		PartitionID int32
		Time        int64
	}
	lockSaramaClientMockGetOffset.RLock()
	calls = mock.calls.GetOffset
	lockSaramaClientMockGetOffset.RUnlock()
	return calls
}

// InSyncReplicas calls InSyncReplicasFunc.
func (mock *SaramaClientMock) InSyncReplicas(topic string, partitionID int32) ([]int32, error) {
	if mock.InSyncReplicasFunc == nil {
		panic("SaramaClientMock.InSyncReplicasFunc: method is nil but SaramaClient.InSyncReplicas was just called")
	}
	callInfo := struct {
		Topic       string
		PartitionID int32
	}{
		Topic:       topic,
		PartitionID: partitionID,
	}
	lockSaramaClientMockInSyncReplicas.Lock()
	mock.calls.InSyncReplicas = append(mock.calls.InSyncReplicas, callInfo)
	lockSaramaClientMockInSyncReplicas.Unlock()
	return mock.InSyncReplicasFunc(topic, partitionID)
}

// InSyncReplicasCalls gets all the calls that were made to InSyncReplicas.
// Check the length with:
//     len(mockedSaramaClient.InSyncReplicasCalls())
func (mock *SaramaClientMock) InSyncReplicasCalls() []struct {
	Topic       string
	PartitionID int32
} {
	var calls []struct {
		Topic       string
		PartitionID int32
	}
	lockSaramaClientMockInSyncReplicas.RLock()
	calls = mock.calls.InSyncReplicas
	lockSaramaClientMockInSyncReplicas.RUnlock()
	return calls
}

// InitProducerID calls InitProducerIDFunc.
func (mock *SaramaClientMock) InitProducerID() (*sarama.InitProducerIDResponse, error) {
	if mock.InitProducerIDFunc == nil {
		panic("SaramaClientMock.InitProducerIDFunc: method is nil but SaramaClient.InitProducerID was just called")
	}
	callInfo := struct {
	}{}
	lockSaramaClientMockInitProducerID.Lock()
	mock.calls.InitProducerID = append(mock.calls.InitProducerID, callInfo)
	lockSaramaClientMockInitProducerID.Unlock()
	return mock.InitProducerIDFunc()
}

// InitProducerIDCalls gets all the calls that were made to InitProducerID.
// Check the length with:
//     len(mockedSaramaClient.InitProducerIDCalls())
func (mock *SaramaClientMock) InitProducerIDCalls() []struct {
} {
	var calls []struct {
	}
	lockSaramaClientMockInitProducerID.RLock()
	calls = mock.calls.InitProducerID
	lockSaramaClientMockInitProducerID.RUnlock()
	return calls
}

// Leader calls LeaderFunc.
func (mock *SaramaClientMock) Leader(topic string, partitionID int32) (*sarama.Broker, error) {
	if mock.LeaderFunc == nil {
		panic("SaramaClientMock.LeaderFunc: method is nil but SaramaClient.Leader was just called")
	}
	callInfo := struct {
		Topic       string
		PartitionID int32
	}{
		Topic:       topic,
		PartitionID: partitionID,
	}
	lockSaramaClientMockLeader.Lock()
	mock.calls.Leader = append(mock.calls.Leader, callInfo)
	lockSaramaClientMockLeader.Unlock()
	return mock.LeaderFunc(topic, partitionID)
}

// LeaderCalls gets all the calls that were made to Leader.
// Check the length with:
//     len(mockedSaramaClient.LeaderCalls())
func (mock *SaramaClientMock) LeaderCalls() []struct {
	Topic       string
	PartitionID int32
} {
	var calls []struct {
		Topic       string
		PartitionID int32
	}
	lockSaramaClientMockLeader.RLock()
	calls = mock.calls.Leader
	lockSaramaClientMockLeader.RUnlock()
	return calls
}

// OfflineReplicas calls OfflineReplicasFunc.
func (mock *SaramaClientMock) OfflineReplicas(topic string, partitionID int32) ([]int32, error) {
	if mock.OfflineReplicasFunc == nil {
		panic("SaramaClientMock.OfflineReplicasFunc: method is nil but SaramaClient.OfflineReplicas was just called")
	}
	callInfo := struct {
		Topic       string
		PartitionID int32
	}{
		Topic:       topic,
		PartitionID: partitionID,
	}
	lockSaramaClientMockOfflineReplicas.Lock()
	mock.calls.OfflineReplicas = append(mock.calls.OfflineReplicas, callInfo)
	lockSaramaClientMockOfflineReplicas.Unlock()
	return mock.OfflineReplicasFunc(topic, partitionID)
}

// OfflineReplicasCalls gets all the calls that were made to OfflineReplicas.
// Check the length with:
//     len(mockedSaramaClient.OfflineReplicasCalls())
func (mock *SaramaClientMock) OfflineReplicasCalls() []struct {
	Topic       string
	PartitionID int32
} {
	var calls []struct {
		Topic       string
		PartitionID int32
	}
	lockSaramaClientMockOfflineReplicas.RLock()
	calls = mock.calls.OfflineReplicas
	lockSaramaClientMockOfflineReplicas.RUnlock()
	return calls
}

// Partitions calls PartitionsFunc.
func (mock *SaramaClientMock) Partitions(topic string) ([]int32, error) {
	if mock.PartitionsFunc == nil {
		panic("SaramaClientMock.PartitionsFunc: method is nil but SaramaClient.Partitions was just called")
	}
	callInfo := struct {
		Topic string
	}{
		Topic: topic,
	}
	lockSaramaClientMockPartitions.Lock()
	mock.calls.Partitions = append(mock.calls.Partitions, callInfo)
	lockSaramaClientMockPartitions.Unlock()
	return mock.PartitionsFunc(topic)
}

// PartitionsCalls gets all the calls that were made to Partitions.
// Check the length with:
//     len(mockedSaramaClient.PartitionsCalls())
func (mock *SaramaClientMock) PartitionsCalls() []struct {
	Topic string
} {
	var calls []struct {
		Topic string
	}
	lockSaramaClientMockPartitions.RLock()
	calls = mock.calls.Partitions
	lockSaramaClientMockPartitions.RUnlock()
	return calls
}

// RefreshCoordinator calls RefreshCoordinatorFunc.
func (mock *SaramaClientMock) RefreshCoordinator(consumerGroup string) error {
	if mock.RefreshCoordinatorFunc == nil {
		panic("SaramaClientMock.RefreshCoordinatorFunc: method is nil but SaramaClient.RefreshCoordinator was just called")
	}
	callInfo := struct {
		ConsumerGroup string
	}{
		ConsumerGroup: consumerGroup,
	}
	lockSaramaClientMockRefreshCoordinator.Lock()
	mock.calls.RefreshCoordinator = append(mock.calls.RefreshCoordinator, callInfo)
	lockSaramaClientMockRefreshCoordinator.Unlock()
	return mock.RefreshCoordinatorFunc(consumerGroup)
}

// RefreshCoordinatorCalls gets all the calls that were made to RefreshCoordinator.
// Check the length with:
//     len(mockedSaramaClient.RefreshCoordinatorCalls())
func (mock *SaramaClientMock) RefreshCoordinatorCalls() []struct {
	ConsumerGroup string
} {
	var calls []struct {
		ConsumerGroup string
	}
	lockSaramaClientMockRefreshCoordinator.RLock()
	calls = mock.calls.RefreshCoordinator
	lockSaramaClientMockRefreshCoordinator.RUnlock()
	return calls
}

// RefreshMetadata calls RefreshMetadataFunc.
func (mock *SaramaClientMock) RefreshMetadata(topics ...string) error {
	if mock.RefreshMetadataFunc == nil {
		panic("SaramaClientMock.RefreshMetadataFunc: method is nil but SaramaClient.RefreshMetadata was just called")
	}
	callInfo := struct {
		Topics []string
	}{
		Topics: topics,
	}
	lockSaramaClientMockRefreshMetadata.Lock()
	mock.calls.RefreshMetadata = append(mock.calls.RefreshMetadata, callInfo)
	lockSaramaClientMockRefreshMetadata.Unlock()
	return mock.RefreshMetadataFunc(topics...)
}

// RefreshMetadataCalls gets all the calls that were made to RefreshMetadata.
// Check the length with:
//     len(mockedSaramaClient.RefreshMetadataCalls())
func (mock *SaramaClientMock) RefreshMetadataCalls() []struct {
	Topics []string
} {
	var calls []struct {
		Topics []string
	}
	lockSaramaClientMockRefreshMetadata.RLock()
	calls = mock.calls.RefreshMetadata
	lockSaramaClientMockRefreshMetadata.RUnlock()
	return calls
}

// Replicas calls ReplicasFunc.
func (mock *SaramaClientMock) Replicas(topic string, partitionID int32) ([]int32, error) {
	if mock.ReplicasFunc == nil {
		panic("SaramaClientMock.ReplicasFunc: method is nil but SaramaClient.Replicas was just called")
	}
	callInfo := struct {
		Topic       string
		PartitionID int32
	}{
		Topic:       topic,
		PartitionID: partitionID,
	}
	lockSaramaClientMockReplicas.Lock()
	mock.calls.Replicas = append(mock.calls.Replicas, callInfo)
	lockSaramaClientMockReplicas.Unlock()
	return mock.ReplicasFunc(topic, partitionID)
}

// ReplicasCalls gets all the calls that were made to Replicas.
// Check the length with:
//     len(mockedSaramaClient.ReplicasCalls())
func (mock *SaramaClientMock) ReplicasCalls() []struct {
	Topic       string
	PartitionID int32
} {
	var calls []struct {
		Topic       string
		PartitionID int32
	}
	lockSaramaClientMockReplicas.RLock()
	calls = mock.calls.Replicas
	lockSaramaClientMockReplicas.RUnlock()
	return calls
}

// Topics calls TopicsFunc.
func (mock *SaramaClientMock) Topics() ([]string, error) {
	if mock.TopicsFunc == nil {
		panic("SaramaClientMock.TopicsFunc: method is nil but SaramaClient.Topics was just called")
	}
	callInfo := struct {
	}{}
	lockSaramaClientMockTopics.Lock()
	mock.calls.Topics = append(mock.calls.Topics, callInfo)
	lockSaramaClientMockTopics.Unlock()
	return mock.TopicsFunc()
}

// TopicsCalls gets all the calls that were made to Topics.
// Check the length with:
//     len(mockedSaramaClient.TopicsCalls())
func (mock *SaramaClientMock) TopicsCalls() []struct {
} {
	var calls []struct {
	}
	lockSaramaClientMockTopics.RLock()
	calls = mock.calls.Topics
	lockSaramaClientMockTopics.RUnlock()
	return calls
}

// WritablePartitions calls WritablePartitionsFunc.
func (mock *SaramaClientMock) WritablePartitions(topic string) ([]int32, error) {
	if mock.WritablePartitionsFunc == nil {
		panic("SaramaClientMock.WritablePartitionsFunc: method is nil but SaramaClient.WritablePartitions was just called")
	}
	callInfo := struct {
		Topic string
	}{
		Topic: topic,
	}
	lockSaramaClientMockWritablePartitions.Lock()
	mock.calls.WritablePartitions = append(mock.calls.WritablePartitions, callInfo)
	lockSaramaClientMockWritablePartitions.Unlock()
	return mock.WritablePartitionsFunc(topic)
}

// WritablePartitionsCalls gets all the calls that were made to WritablePartitions.
// Check the length with:
//     len(mockedSaramaClient.WritablePartitionsCalls())
func (mock *SaramaClientMock) WritablePartitionsCalls() []struct {
	Topic string
} {
	var calls []struct {
		Topic string
	}
	lockSaramaClientMockWritablePartitions.RLock()
	calls = mock.calls.WritablePartitions
	lockSaramaClientMockWritablePartitions.RUnlock()
	return calls
}
